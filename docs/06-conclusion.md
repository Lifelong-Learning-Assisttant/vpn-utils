# Заключение

Добавленное наблюдение — что Kilo CLI внутри vpn-ns уже корректно использует `tun0` — даёт нам устойчивую стратегию: **сделать так, чтобы VS Code extension делегировал LLM-запросы локальному backend/CLI, или чтобы code-server процесс использовал http-proxy внутри vpn**, тогда все LLM-вызовы от расширения также пойдут через VPN.

Архитектура обеспечивает:

* ✅ Независимое управление контейнерами через отдельные docker-compose файлы
* ✅ Гибкую сеть с external: true и bootstrap
* ✅ Безопасное разделение инфраструктуры (vpn) и клиентов (dev/apps)
* ✅ Минимальные изменения в приложениях — только LLM-вызовы через proxy
* ✅ Изоляцию developer credentials внутри dev-контейнера
* ✅ Отсутствие изменений в глобальной маршрутизации хоста

---

## Важно — примечания и варианты доработки

* **adguardvpn-cli:** В Dockerfile я не устанавливаю специальный VPN-клиент (adguardvpn-cli), т.к. он может требовать приватных пакетов/ключей и лицензий. В `entrypoint.sh` есть точки подключения — если вы используете `adguardvpn-cli`, добавьте шаг установки в Dockerfile и установите токен через переменную окружения `ADGUARDVPN_TOKEN`.
* **DNS:** В контейнере поднят `dnsmasq`, который перенаправляет на публичные AdGuard DNS (94.140.14.14/15). Это обеспечивает, что резолв происходит внутри vpn-namespace.
* **Безопасность:** не пробрасывайте прокси-порты на хост. Разрешения доступа на прокси можно ограничить в конфиге tinyproxy/danted.
* **Маршрутизация:** мы **не** трогаем глобальные таблицы маршрутизации хоста — всё происходит внутри vpn контейнера (tun0).
* **Dev credentials:** developer credentials хранятся в `dev-data` volume; если хотите, используйте anonymous volume или tmpfs для полного исчезновения при rm.
* **Apps:** приложения подключаются к `vpn-net` и должны направлять LLM-вызовы на `socks5h://vpn:1080` или `http://vpn:1090`. Для Python: используйте `socks5h` чтобы DNS разрешение происходило внутри VPN.
